package main

import (
	"fmt"
	"github.com/godoes/gorm-dameng"
	"gorm.io/gorm"
	"time"
)

type TableColType struct {
	TABLECAT          string `gorm:"column:TABLE_CAT"`
	TABLESCHEM        string `gorm:"column:TABLE_SCHEM"`
	TABLENAME         string `gorm:"column:TABLE_NAME"`
	COLUMNNAME        string `gorm:"column:COLUMN_NAME"`
	DATATYPE          int    `gorm:"column:DATA_TYPE"`
	TYPENAME          string `gorm:"column:TYPE_NAME"`
	COLUMNSIZE        int    `gorm:"column:COLUMN_SIZE"`
	BUFFERLENGTH      int    `gorm:"column:BUFFER_LENGTH"`
	DECIMALDIGITS     string `gorm:"column:DECIMAL_DIGITS"`
	NUMPRECRADIX      int    `gorm:"column:NUM_PREC_RADIX"`
	NULLABLE          int    `gorm:"column:NULLABLE"`
	REMARKS           string `gorm:"column:REMARKS"`
	COLUMNDEF         string `gorm:"column:COLUMN_DEF"`
	SQLDATATYPE       int    `gorm:"column:SQL_DATA_TYPE"`
	SQLDATETIMESUB    int    `gorm:"column:SQL_DATETIME_SUB"`
	CHAROCTETLENGTH   int    `gorm:"column:CHAR_OCTET_LENGTH"`
	ORDINALPOSITION   int    `gorm:"column:ORDINAL_POSITION"`
	ISNULLABLE        string `gorm:"column:IS_NULLABLE"`
	SCOPECATLOG       string `gorm:"column:SCOPE_CATLOG"`
	SCOPESCHEMA       string `gorm:"column:SCOPE_SCHEMA"`
	SCOPETABLE        string `gorm:"column:SCOPE_TABLE"`
	SOURCEDATATYPE    int    `gorm:"column:SOURCE_DATA_TYPE"`
	ISAUTOINCREMENT   string `gorm:"column:IS_AUTOINCREMENT"`
	ISGENERATEDCOLUMN string `gorm:"column:IS_GENERATEDCOLUMN"`
}

func highSql(sqlStr string) {
	options := map[string]string{
		"schema":         "SYSDBA",
		"appName":        "GORM连接达梦数据库示例",
		"connectTimeout": "30000",
	}
	dsn := dameng.BuildUrl("SYSDBA", "123", "192.168.219.253", 5236, options)
	db, err := gorm.Open(dameng.Open(dsn), &gorm.Config{})
	if err != nil {
		// panic error or log error info
	}

	var sqlRet []TableColType
	// 创建一个每隔1秒触发一次的Ticker
	ticker := time.NewTicker(10 * time.Millisecond)
	count := 0
	for range ticker.C {
		db.Raw(sqlStr).Scan(&sqlRet)
		count++
		fmt.Println("第", count, "次执行:", sqlRet)
	}

}

func highSql2(index int, sqlStr string) {
	options := map[string]string{
		"schema":         "SYSDBA",
		"appName":        "GORM连接达梦数据库示例",
		"connectTimeout": "30000",
	}
	dsn := dameng.BuildUrl("SYSDBA", "123", "192.168.219.253", 5236, options)
	db, err := gorm.Open(dameng.Open(dsn), &gorm.Config{})
	if err != nil {
		// panic error or log error info
	}

	var sqlRet []TableColType
	// 创建一个每隔1秒触发一次的Ticker
	db.Raw(sqlStr).Scan(&sqlRet)
	fmt.Println("第", index, "次执行:", sqlRet)

}

func main() {
	// heyang
	sqlStr := "/*+ gateway metadata JDBC_getColumns('SMARTSITE3_0_WXKF','SMARTSITE3_0_WXKF','FRAME_ANTI_TAMPER',null)*/ SELECT /*+ MAX_OPT_N_TABLES(5) */ DISTINCT NULL AS TABLE_CAT, SCHS.NAME AS TABLE_SCHEM, TABS.NAME AS TABLE_NAME, COLS.NAME AS COLUMN_NAME, CASE COLS.TYPE$ WHEN 'BOOL' THEN 16 WHEN 'BOOLEAN' THEN 16 WHEN 'BIT' THEN -7 WHEN 'NUMBER' THEN 3 WHEN 'NUMERIC' THEN 3 WHEN 'DEC' THEN 3 WHEN 'DECIMAL' THEN 3 WHEN 'INT' THEN 4 WHEN 'INTEGER' THEN 4 WHEN 'BIGINT' THEN -5 WHEN 'TINYINT' THEN -6 WHEN 'SMALLINT' THEN 5 WHEN 'FLOAT' THEN 6 WHEN 'DOUBLE' THEN 8 WHEN 'REAL' THEN 7 WHEN 'DOUBLE PRECISION' THEN 8 WHEN 'CHARACTER' THEN 1 WHEN 'VARCHAR' THEN 12 WHEN 'VARCHAR2' THEN 12 WHEN 'TEXT' THEN -1 WHEN 'LONGVARCHAR' THEN -1 WHEN 'CLOB' THEN 2005 WHEN 'BYTE' THEN -6 WHEN 'BINARY' THEN -2 WHEN 'VARBINARY' THEN -3 WHEN 'LONGVARBINARY' THEN -4 WHEN 'BLOB' THEN 2004 WHEN 'IMAGE' THEN -4 WHEN 'TIMESTAMP' THEN 93 WHEN 'DATE' THEN 91 WHEN 'TIME' THEN 92 WHEN 'DATETIME' THEN 93 WHEN 'CURSOR' THEN -10 ELSE SF_GET_DATA_TYPE(COLS.TYPE$, CAST(COLS.SCALE AS INT), 3) END AS DATA_TYPE,CASE INSTR(COLS.TYPE$,'CLASS',1,1) WHEN 0 THEN COLS.TYPE$ ELSE SF_GET_CLASS_NAME(COLS.TYPE$) END AS TYPE_NAME,CASE SF_GET_COLUMN_SIZE(COLS.TYPE$, CAST (COLS.LENGTH$ AS INT), CAST (COLS.SCALE AS INT)) WHEN -2 THEN NULL ELSE SF_GET_COLUMN_SIZE(COLS.TYPE$, CAST (COLS.LENGTH$ AS INT), CAST (COLS.SCALE AS INT)) END AS COLUMN_SIZE,CASE SF_GET_BUFFER_LEN(COLS.TYPE$, CAST (COLS.LENGTH$ AS INT), CAST (COLS.SCALE AS INT)) WHEN -2 THEN NULL ELSE SF_GET_BUFFER_LEN(COLS.TYPE$, CAST (COLS.LENGTH$ AS INT), CAST (COLS.SCALE AS INT)) END AS BUFFER_LENGTH,CASE SF_GET_DECIMAL_DIGITS(COLS.TYPE$, CAST (COLS.SCALE AS INT)) WHEN -2 THEN NULL ELSE SF_GET_DECIMAL_DIGITS(COLS.TYPE$, CAST (COLS.SCALE AS INT)) END AS DECIMAL_DIGITS,10 AS NUM_PREC_RADIX,CASE COLS.NULLABLE$ WHEN 'Y' THEN 1 ELSE 0 END AS NULLABLE,(SELECT COMMENT$ FROM SYS.SYSCOLUMNCOMMENTS WHERE SCHNAME=SCHS.NAME AND TVNAME=TABS.NAME AND COLNAME=COLS.NAME) AS REMARKS,COLS.DEFVAL AS COLUMN_DEF,0 AS SQL_DATA_TYPE,0 AS SQL_DATETIME_SUB,CASE SF_GET_OCT_LENGTH(COLS.TYPE$, CAST (COLS.LENGTH$ AS INT)) WHEN -2 THEN NULL ELSE SF_GET_OCT_LENGTH(COLS.TYPE$, CAST (COLS.LENGTH$ AS INT)) END AS CHAR_OCTET_LENGTH,COLS.COLID + 1 AS ORDINAL_POSITION,CASE COLS.NULLABLE$ WHEN 'Y' THEN 'YES' ELSE 'NO' END AS IS_NULLABLE,NULL AS SCOPE_CATLOG,NULL AS SCOPE_SCHEMA,NULL AS SCOPE_TABLE,0 AS SOURCE_DATA_TYPE, CASE COLS.INFO2 & 0x01 WHEN 1 THEN 'YES' ELSE 'NO' END AS IS_AUTOINCREMENT, CASE (select INFO1 & 0x01 from SYS.SYSCOLINFOS where ID = COLS.ID and COLID = COLS.COLID) WHEN 1 THEN 'YES' ELSE 'NO' END AS IS_GENERATEDCOLUMN FROM (SELECT ID, PID, NAME FROM SYS.SYSOBJECTS WHERE TYPE$ = 'SCH' AND NAME LIKE 'SMARTSITE3_0_WXKF'  ESCAPE '!' )SCHS, (SELECT ID, SCHID, NAME FROM SYS.SYSOBJECTS WHERE TYPE$ = 'SCHOBJ' AND SUBTYPE$ IN ('UTAB', 'STAB', 'VIEW')AND NAME LIKE 'FRAME_ANTI_TAMPER'  ESCAPE '!' )TABS, (SELECT A.NAME AS NAME, A.ID AS ID,A.COLID AS COLID, CASE WHEN B.INFO1 IS NULL OR ((B.INFO1>>2) & 0x01)=0 THEN A.TYPE$ WHEN (B.INFO2 & 0xFF) = 0 THEN 'NUMBER' ELSE 'FLOAT' END AS TYPE$, CASE WHEN B.INFO1 IS NULL OR ((B.INFO1>>2) & 0x01)=0 THEN A.LENGTH$ ELSE (B.INFO2 & 0xFF) END AS LENGTH$,CASE WHEN B.INFO1 IS NULL OR ((B.INFO1>>2) & 0x01)=0 THEN A.SCALE WHEN (B.INFO2 & 0xFF) = 0 THEN 0 ELSE 129 END AS SCALE,A.NULLABLE$ AS NULLABLE$,A.DEFVAL AS DEFVAL,A.INFO1 AS INFO1,A.INFO2 AS INFO2 FROM SYS.SYSCOLUMNS A LEFT JOIN SYS.SYSCOLINFOS B ON A.ID = B.ID AND A.COLID = B.COLID )COLS WHERE TABS.ID = COLS.ID AND SCHS.ID = TABS.SCHID  ORDER BY TABLE_SCHEM ASC,TABLE_NAME ASC,ORDINAL_POSITION ASC;"
	// yzj
	//sqlStr := "SELECT /*+ MAX_OPT_N_TABLES(5) */ DISTINCT NULL AS TABLE_CAT, SCHS.NAME AS TABLE_SCHEM, TABS.NAME AS TABLE_NAME, COLS.NAME AS COLUMN_NAME, CASE COLS.TYPE$ WHEN 'NUMBER' THEN 2 WHEN 'NUMERIC' THEN 2 WHEN 'TIMESTAMP' THEN 93 WHEN 'CHARACTER' THEN 1 WHEN 'VARCHAR' THEN 12 WHEN 'VARCHAR2' THEN 12 WHEN 'DEC' THEN 3 WHEN 'DECIMAL' THEN 3 WHEN 'BIT' THEN -7 WHEN 'INT' THEN 4 WHEN 'INTEGER' THEN 4 WHEN 'BIGINT' THEN -5 WHEN 'BYTE' THEN -6 WHEN 'TINYINT' THEN -6 WHEN 'SMALLINT' THEN 5 WHEN 'BINARY' THEN -2 WHEN 'VARBINARY' THEN -3 WHEN 'FLOAT' THEN 6 WHEN 'DOUBLE' THEN 8 WHEN 'REAL' THEN 7 WHEN 'DOUBLE PRECISION' THEN 8 WHEN 'DATE' THEN 91 WHEN 'TIME' THEN 92 WHEN 'DATETIME' THEN 93 WHEN 'TEXT' THEN -1 WHEN 'LONGVARCHAR' THEN -1 WHEN 'IMAGE' THEN -4 WHEN 'LONGVARBINARY' THEN -4 WHEN 'BLOB' THEN 2004 WHEN 'CLOB' THEN 2005 WHEN 'CURSOR' THEN -10 WHEN 'BOOL' THEN 16 WHEN 'BOOLEAN' THEN 16 ELSE SF_GET_DATA_TYPE(COLS.TYPE$, CAST(COLS.SCALE AS INT), 3) END AS DATA_TYPE,CASE INSTR(COLS.TYPE$,'CLASS',1,1) WHEN 0 THEN COLS.TYPE$ ELSE SF_GET_CLASS_NAME(COLS.TYPE$) END AS TYPE_NAME,CASE SF_GET_COLUMN_SIZE(COLS.TYPE$, CAST (COLS.LENGTH$ AS INT), CAST (COLS.SCALE AS INT)) WHEN -2 THEN NULL ELSE SF_GET_COLUMN_SIZE(COLS.TYPE$, CAST (COLS.LENGTH$ AS INT), CAST (COLS.SCALE AS INT)) END AS COLUMN_SIZE,CASE SF_GET_BUFFER_LEN(COLS.TYPE$, CAST (COLS.LENGTH$ AS INT), CAST (COLS.SCALE AS INT)) WHEN -2 THEN NULL ELSE SF_GET_BUFFER_LEN(COLS.TYPE$, CAST (COLS.LENGTH$ AS INT), CAST (COLS.SCALE AS INT)) END AS BUFFER_LENGTH,CASE SF_GET_DECIMAL_DIGITS(COLS.TYPE$, CAST (COLS.SCALE AS INT)) WHEN -2 THEN NULL ELSE SF_GET_DECIMAL_DIGITS(COLS.TYPE$, CAST (COLS.SCALE AS INT)) END AS DECIMAL_DIGITS,10 AS NUM_PREC_RADIX,CASE COLS.NULLABLE$ WHEN 'Y' THEN 1 ELSE 0 END AS NULLABLE,(SELECT COMMENT$ FROM SYSCOLUMNCOMMENTS WHERE SCHNAME=SCHS.NAME AND TVNAME=TABS.NAME AND COLNAME=COLS.NAME) AS REMARKS,COLS.DEFVAL AS COLUMN_DEF,0 AS SQL_DATA_TYPE,0 AS SQL_DATETIME_SUB,CASE SF_GET_OCT_LENGTH(COLS.TYPE$, CAST (COLS.LENGTH$ AS INT)) WHEN -2 THEN NULL ELSE SF_GET_OCT_LENGTH(COLS.TYPE$, CAST (COLS.LENGTH$ AS INT)) END AS CHAR_OCTET_LENGTH,COLS.COLID + 1 AS ORDINAL_POSITION,CASE COLS.NULLABLE$ WHEN 'Y' THEN 'YES' ELSE 'NO' END AS IS_NULLABLE,NULL AS SCOPE_CATLOG,NULL AS SCOPE_SCHEMA,NULL AS SCOPE_TABLE,0 AS SOURCE_DATA_TYPE, CASE COLS.INFO2 & 0x01 WHEN 1 THEN 'YES' ELSE 'NO' END AS IS_AUTOINCREMENT, CASE (select INFO1 & 0x01 from SYS.SYSCOLINFOS where ID = COLS.ID and COLID = COLS.COLID) WHEN 1 THEN 'YES' ELSE 'NO' END AS IS_GENERATEDCOLUMN FROM (SELECT ID, PID, NAME FROM SYS.SYSOBJECTS WHERE TYPE$ = 'SCH' AND NAME LIKE 'EDC_4_1_2_PUBLISH'  ESCAPE '!' )SCHS, (SELECT ID, SCHID, NAME FROM SYS.SYSOBJECTS WHERE TYPE$ = 'SCHOBJ' AND SUBTYPE$ IN ('UTAB', 'STAB', 'VIEW')AND NAME LIKE 'FRAME_MODULERIGHT'  ESCAPE '!' )TABS, (SELECT * FROM SYS.SYSCOLUMNS)COLS WHERE TABS.ID = COLS.ID AND SCHS.ID = TABS.SCHID  ORDER BY TABLE_SCHEM ASC,TABLE_NAME ASC,ORDINAL_POSITION ASC;"
	// 模拟大量并发sql
	for i := 0; i < 200; i++ {
		fmt.Println("并发执行", i, time.Now())
		go highSql2(i, sqlStr)
	}
	time.Sleep(10000 * time.Second)
	fmt.Println("ok")
}
